2. main.js (Electron Main Process)


   * Purpose: This is the core Electron main process. It sets up the Electron window, initializes a Socket.IO
     server for inter-process communication (IPC) with renderer processes, and orchestrates interactions
     between various backend modules (obsidianmode, vnmanager, chaptermanagement, narrativeEngine). It acts as the central hub
     for application logic not directly tied to the UI. It also supports a Command-Line Interface (CLI) mode for headless operation.
   * Main Functions:
       * parseArgs(): Parses command-line arguments to determine if running in CLI mode and extract relevant parameters.
       * getProjectName(): Derives project name from rootDirectory.
       * getProjectFiles(subdir, extensions): Helper to get project-specific assets (sprites, backgrounds, OSTs).
       * getProjectSprites(), getProjectBackgrounds(), getProjectOSTs(): Specific helpers for retrieving project assets.
       * addEmitReceiveToSocket(socket): Extends Socket.IO sockets for request-response patterns with timeout and cleanup.
       * emitResponse(eventName, data): Helper for consistent Socket.IO responses.
       * projectHandlers (object): Contains async functions for project management operations (getAllProjects, createNewProject, selectProject).
       * characterHandlers (object): Contains async functions for character-related operations (resolveMainCharacterName, getMainCharacterName).
       * fileHandlers (object): Contains async functions for file-related operations, including `sendToLLM` (now using `narrativeEngine`).
       * vnHandlers (object): Contains async functions for Visual Novel operations, including `generateVNTurn` which orchestrates the VN pipeline.
       * chapterHandlers (object): Contains async functions for chapter management (saveMessageChapter).
       * memoryHandlers (object): Contains async functions for memory inspection operations (getMemoryData) requested by the memory inspector renderer.
       * logHandlers (object): Contains async functions for log file operations (getAllLogs, getLogContent, getLogProjects, getCurrentProjectName, getModelPricing).
       * setupSocketConnection(socket): Configures event listeners for a new Socket.IO client connection.
       * initializeNarrativeEngine(): Initializes the `narrativeEngine` module, injecting necessary dependencies.
       * startSocketServer(): Starts the Socket.IO server.
       * initializeElectronWindow(): Creates and manages the Electron browser window (GUI mode).
       * runCliMode(args): Executes the application in CLI mode, simulating renderer interactions and calling core handlers directly.
   * Modularity: Good. It delegates specific tasks to imported modules (obsidianmode, vnmanager, chaptermanagement, narrativeEngine, utils) and organizes event handlers by domain.
   * Dependencies: electron, path, fs/promises, http, socket.io (for server), obsidianmode.js, vnmanager/vnmanager.js, chaptermanagement.js, narrativeEngine.js, utils.js. Note: Interactions with renderer processes like `views/obsidian_mode/renderer_obsidian_mode.js` occur via Socket.IO, not direct imports.
   * Flow Analysis:
       1. Startup: Application starts, `parseArgs()` determines mode. `startSocketServer()` and `initializeNarrativeEngine()` always run.
           * **GUI Mode:** `app.whenReady()` -> `initializeElectronWindow()` (loads index.html). Various renderer processes (e.g., `renderer.js`, `renderer_vn.js`, `renderer_obsidian_mode.js`) connect to Socket.IO.
           * **CLI Mode:** `app.whenReady()` -> `runCliMode(cliArgs)`. This function simulates renderer interactions to drive the core logic.
       2. Socket.IO Server: `startSocketServer()` sets up the server, listening for client connections.
       3. Client Connection (GUI Mode): When a renderer connects (from the main UI, VN viewer, memory inspector, or Obsidian Mode), setupSocketConnection() registers handlers for various events.
       4. Socket Flow (GUI Mode): Renderer processes (e.g., `renderer.js`, `renderer_vn.js`) emit events to `main.js`. `main.js` then
          calls appropriate handler functions, which often interact with other backend modules (e.g.,
          `narrativeEngine.generateNextChapter`, `vnmanager.transformVNProject`). Results are sent back to the renderer via
          Socket.IO responses.
       5. CLI Flow: `runCliMode` directly calls `vnHandlers.generateVNTurn` (or other relevant handlers) with a simulated socket object, bypassing the GUI.
       6. File System/LLM Interaction: `main.js` acts as a proxy, receiving requests from renderers (or simulating them in CLI mode),
          performing file system operations (via `fs` or `obsidianmode`), making LLM calls (via `narrativeEngine` which uses
          `utils.openrouterRequest`), and managing project-specific assets.
       7. VN Turn Generation (`generateVNTurn`):
           * Gathers context (selected files, main character, chat file path) from renderer (or simulated in CLI).
           * **Crucially, a `TurnContext` object (`newTurnContext.init()`) is now created and initialized. This object acts as a comprehensive, self-contained capsule for all turn-specific data, eliminating the need for complex, cascading parameter passing across functions and modules. It centralizes access to the current turn's state, inputs, and outputs.**
           * Calls `narrativeEngine.generateNextChapter(newTurnContext)` to get the core story text and any Turn 0 orchestrator feedback, which are populated directly into `newTurnContext`.
           * Calls `vnmanager.transformVNProject(newTurnContext)` to convert the story text into a VN sequence, passing the `TurnContext` object which contains all necessary project assets and chapter history.
           * **The `TurnContext` object is then committed to the chapter file via `newTurnContext.commit()`, saving the complete turn (prompt + story text + VN sequence + orchestrator feedback). This ensures a consistent and complete record of each turn.**
           * Emits the final VN result (contained within `newTurnContext.output`) to the renderer (or logs in CLI mode).

       8. Memory Inspection Flow (renderer_memory.js):
           * The Memory Inspector tab loads `inspector.html`, which runs `renderer_memory.js`.
           * User clicks "Refresh Data" in the inspector UI.
           * `renderer_memory.js` emits a `get-memory-data` event to `main.js`, specifying which data store to inspect (e.g., 'chapters').
           * `main.js`'s `memoryHandlers.getMemoryData` function is triggered.
           * It calls `memorymanagement.inspectStore` to query the ChromaDB vector store for all its contents.
           * The raw data (documents, metadata, IDs) is sent back to `renderer_memory.js` via a `get-memory-data-response` event.
           * `renderer_memory.js` receives the data and dynamically renders it into a grid for user inspection.

       9. Log Viewer Workflow (renderer_logs.js):
           * User navigates to the "Log Viewer" tab in the main application window.
           * This loads a separate webview containing `logs.html` and its script, `renderer_logs.js`.
           * `renderer_logs.js` emits a `get-logs` event to `main.js`.
           * `main.js` receives the event and calls `logHandlers.getAllLogs` to read the log files from the `logs/` directory.
           * `main.js` sends the log data back to `renderer_logs.js` via a `get-all-logs-response` event.
           * The log viewer UI receives the data and displays it.
           * When a user requests content of a specific log file, `renderer_logs.js` emits `get-log-content` and `main.js`'s `logHandlers.getLogContent` reads and returns the file content.